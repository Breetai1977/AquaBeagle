/****************************************************************************
 * Ephemeris.js
 * (c) 2014, Brian Harris
 * Library for calculating sun and moon rise/set times and moon phases.
 * Formulas are from the USNO  http://aa.usno.navy.mil/faq/rs_algor.php.
*****************************************************************************/

// shortcuts for math functions
var PI = Math.PI,
    sin = Math.sin,
    cos = Math.cos,
    tan = Math.tan,
    asin = Math.asin,
    atan = Math.atan2,
    acos = Math.acos,
    sqrt = Math.sqrt,
    floor = Math.floor,
    round = Math.round,
    radians = PI / 180,
    K1 = 15 * radians * 1.0027379;

// Date and time constants
var dayMs = 1000 * 60 * 60 * 24,
    J1970 = 2440588,
    J2000 = 2451545;

/*
 * Returns the Julian day for the specified date.
 * param: date: Javascript UTC date.
 */
exports.toJulian = function(date) {
    return date / dayMs - 0.5 + J1970;
};

/*
 * Returns a JavaScript date object equal to the specified Julian day.
 */
exports.fromJulian = function(j) {
    return (j + 0.5 - J1970) * dayMs;
};

/*
 * Returns the number of Julian days since the beginning of the millennium/epoch 2000.
 */
exports.toDays = function(date) {
    return exports.toJulian(date) - J2000;
};

/*
 * Returns the specified Degrees value in Radians.
 */
exports.toRadians = function(deg) {
    return deg * (PI / 180);
};

/*
 * Returns the specified Radians in Degrees.
 */
exports.toDegrees = function (rad) {
    return rad * 180 / PI;
};

// Position functions
var e = radians * 23.4397; // Obliquity of the Earth

function getRightAscension(l, b) {
    return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
}

function getDeclination(l, b) {
    return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
}

function getAzimuth(H, phi, dec) {
    return PI + atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
}

function getAltitude(H, phi, dec) {
    return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
}

function getSiderealTime(d, lw) {
    return radians * (280.16 + 360.9856235 * d) - lw;
}

// General Solar calculations, needed by both Sun and Moon objects
function getSolarMeanAnomaly(d) {
    return radians * (357.5291 + 0.98560028 * d);
}

function getEquationOfCenter(M) {
    return radians * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 0.0003 * sin(3 * M));
}

function getEclipticLongitude(M, C) {
    var P = radians * 102.9372; // Perihelion of the Earth
    return M + C + P + PI;
}

function getSunCoordinates(d) {
    var M = getSolarMeanAnomaly(d),
        C = getEquationOfCenter(M),
        L = getEclipticLongitude(M, C);

    return {
        dec: getDeclination(L, 0),
        ra: getRightAscension(L, 0)
    };
}

// Calculations for Sun times
var times = [
    [-0.83, 'sunrise', 'sunset'],
    [-0.3, 'sunriseEnd', 'sunsetStart'],
    [-6, 'dawn', 'dusk'],
    [-12, 'nauticalDawn', 'nauticalDusk'],
    [-18, 'nightEnd', 'night']
];

var J0 = 0.0009;

function getJulianCycle(d, lw) {
    return Math.round(d - J0 - lw / (2 * PI));
}

function getApproxTransit(Ht, lw, n) {
    return J0 + (Ht + lw) / (2 * PI) + n;
}

function getSolarTransitJ(ds, M, L) {
    return J2000 + ds + 0.0053 * sin(M) - 0.0069 * sin(2 * L) + 1;
}

function getHourAngle(h, phi, d) {
    return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d)));
}

function getSetTimeJ(h, lw, phi, dec, n, M, L) {
    var w = getHourAngle(h, phi, dec),
        a = getApproxTransit(w, lw, n);

    return getSolarTransitJ(a, M, L);
}

// Calculations for Moon times

function getMoonCoordinates(d) { // geocentric ecliptic coordinates of the moon
    var L = radians * (218.316 + 13.176396 * d), // ecliptic longitude
        M = radians * (134.963 + 13.064993 * d), // mean anomaly
        F = radians * (93.272 + 13.229350 * d), // mean distance
        l = L + radians * 6.289 * sin(M), // longitude
        b = radians * 5.128 * sin(F), // latitude
        dt = 385001 - 20905 * cos(M); // distance to moon in km

    return {
        ra: getRightAscension(l, b),
        dec: getDeclination(l, b),
        dist: dt
    };
}

// Moon's position using fundamental arguments
function getMoonPosition(jd) {
    var h = 0.606434 + 0.03660110129*jd,
        m = 0.374897 + 0.03629164709*jd,
        f = 0.259091 + 0.0367481952 *jd,
        d = 0.827362 + 0.03386319198*jd,
        n = 0.347343 - 0.00014709391*jd,
        g = 0.993126 + 0.0027377785 *jd,
        ra, dec, u, v, w;

    h = h - floor(h);
    m = m - floor(m);
    f = f - floor(f);
    d = d - floor(d);
    n = n - floor(n);
    g = g - floor(g);

    h = h*2*PI;
    m = m*2*PI;
    f = f*2*PI;
    d = d*2*PI;
    n = n*2*PI;
    g = g*2*PI;

    v = 0.39558*sin(f + n);
    v = v + 0.082  *sin(f);
    v = v + 0.03257*sin(m - f - n);
    v = v + 0.01092*sin(m + f + n);
    v = v + 0.00666*sin(m - f);
    v = v - 0.00644*sin(m + f - 2*d + n);
    v = v - 0.00331*sin(f - 2*d + n);
    v = v - 0.00304*sin(f - 2*d);
    v = v - 0.0024 *sin(m - f - 2*d - n);
    v = v + 0.00226*sin(m + f);
    v = v - 0.00108*sin(m + f - 2*d);
    v = v - 0.00079*sin(f - n);
    v = v + 0.00078*sin(f + 2*d + n);

    u = 1 - 0.10828*cos(m);
    u = u - 0.0188 *cos(m - 2*d);
    u = u - 0.01479*cos(2*d);
    u = u + 0.00181*cos(2*m - 2*d);
    u = u - 0.00147*cos(2*m);
    u = u - 0.00105*cos(2*d - g);
    u = u - 0.00075*cos(m - 2*d + g);

    w = 0.10478*sin(m);
    w = w - 0.04105*sin(2*f + 2*n);
    w = w - 0.0213 *sin(m - 2*d);
    w = w - 0.01779*sin(2*f + n);
    w = w + 0.01774*sin(n);
    w = w + 0.00987*sin(2*d);
    w = w - 0.00338*sin(m - 2*f - 2*n);
    w = w - 0.00309*sin(g);
    w = w - 0.0019 *sin(2*f);
    w = w - 0.00144*sin(m + n);
    w = w - 0.00144*sin(m - 2*f - n);
    w = w - 0.00113*sin(m + 2*f + 2*n);
    w = w - 0.00094*sin(m - 2*d + g);
    w = w - 0.00092*sin(2*m - 2*d);

    ra = w / sqrt(u - v*v);
    dec = v / sqrt(u);

    return {
        ra: h + Math.atan(ra / sqrt(1 - ra*ra)),
        dec: Math.atan(dec / sqrt(1 - dec*dec)),
        plx: 60.40974 * sqrt(u)
    };
}

// 3-point interpolation
function interpolate(f0, f1, f2, p) {
    var a = f1 - f0;
    var b = f2 - f1 - a;
    return f0 + p * (2 * a + b * (2 * p - 1));
}

// Local sidereal time for zone.
function lst(lng, jd, z) {
    var s = 24110.5 + 8640184.812999999*jd/36525 + 86636.6*z + 86400*lng;
    s = s/86400;
    s = s - floor(s);
    return s*360*radians;
}

// test an hour for an event (rise/set)
function moonTest(k, t0, lat, plx, RAn, Dec, VHz, result) {
    var ha = [0.0, 0.0, 0.0];
    var a, b, c, d, e, s, z;
    var time;

    if (RAn[2] < RAn[0])
        RAn[2] = RAn[2] + 2*PI;

    ha[0] = t0 - RAn[0] + k*K1;
    ha[2] = t0 - RAn[2] + k*K1 + K1;

    ha[1]  = (ha[2] + ha[0])/2;                // hour angle at half hour
    Dec[1] = (Dec[2] + Dec[0])/2;              // declination at half hour

    s = sin(radians*lat);
    c = cos(radians*lat);

    // refraction + sun semidiameter at horizon + parallax correction
    z = cos(radians*(90.567 - 41.685/plx));

    if (k <= 0)                                // first call of function
        VHz[0] = s*sin(Dec[0]) + c*cos(Dec[0])*cos(ha[0]) - z;

    VHz[2] = s*sin(Dec[2]) + c*cos(Dec[2])*cos(ha[2]) - z;

    if (sgn(VHz[0]) == sgn(VHz[2]))
        return VHz[2];                         // no event this hour

    VHz[1] = s*sin(Dec[1]) + c*cos(Dec[1])*cos(ha[1]) - z;

    a = 2*VHz[2] - 4*VHz[1] + 2*VHz[0];
    b = 4*VHz[1] - 3*VHz[0] - VHz[2];
    d = b*b - 4*a*VHz[0];

    if (d < 0)
        return VHz[2];                         // no event this hour

    d = sqrt(d);
    e = (-b + d)/(2*a);

    if (( e > 1 )||( e < 0 ))
        e = (-b - d)/(2*a);

    time = k + e + 1/120;                      // time of an event + round up

    if ((VHz[0] < 0)&&(VHz[2] > 0)) {
        result.moonrise = time;
    }

    if ((VHz[0] > 0)&&(VHz[2] < 0)) {
        result.moonset = time;
    }

    return VHz[2];
}

// returns value for the sign of argument
function sgn(x) {
    var rv;
    if (x > 0.0)      rv =  1;
    else if (x < 0.0) rv = -1;
    else              rv =  0;
    return rv;
}

// Sun object
exports.Sun = {

    /*
     * Calculates the Sun position for a given date and latitude/longitude.
     */
    getPosition: function(date, lat, lng) {
        var lw = radians *  -lng,
            phi = radians * lat,
            d = exports.toDays(date),
            c = getSunCoordinates(d),
            H = getSiderealTime(d, lw) - c.ra;

        return {
            azimuth: getAzimuth(H, phi, c.dec),
            altitude: getAltitude(H, phi, c.dec)
        };
    },

    /*
     * Adds a custom time to the results of the getTimes function.
     */
    addTime: function(angle, riseName, setName) {
        times.push([angle, riseName, setName]);
    },

    /*
     * Calculates the Sun rise/set times for a given date and latitude/longitude.
     */
    getTimes: function(date, lat, lng) {
        //date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0, 0, 0);

        var lw = radians * -lng,
            phi = radians * lat,
            d = exports.toDays(date),
            n = getJulianCycle(d, lw),
            ds = getApproxTransit(0, lw, n),
            M = getSolarMeanAnomaly(ds),
            C = getEquationOfCenter(M),
            L = getEclipticLongitude(M, C),
            dec = getDeclination(L, 0),
            Jnoon = getSolarTransitJ(ds, M, L);

        var result = {
            solarNoon: exports.fromJulian(Jnoon),
            nadir: exports.fromJulian(Jnoon - 0.5)
        };

        var i, len, time, Jset, Jrise;
        for (i = 0, len = times.length; i < len; i += 1) {
            time = times[i];

            Jset = getSetTimeJ(time[0] * radians, lw, phi, dec, n, M, L);
            Jrise = Jnoon - (Jset - Jnoon);

            result[time[1]] = exports.fromJulian(Jrise);
            result[time[2]] = exports.fromJulian(Jset);
        }

        return result;
    }
};

// Moon object
exports.Moon = {
    /*
     * Calculates the Moon position for a given date and latitude/longitude.
     */
    getPosition: function(date, lat, lng) {
        var lw = radians * -lng,
            phi = radians * lat,
            d = exports.toDays(date),
            c = getMoonCoordinates(d),
            H = getSiderealTime(d, lw) - c.ra,
            h = getAltitude(H, phi, c.dec);

        // altitude correction for refraction
        h = h + radians * 0.017 / tan(h + radians * 10.26 / (h + radians * 5.10));

        return {
            azimuth: getAzimuth(H, phi, c.dec),
            altitude: h,
            distance: c.dist
        };
    },

    /*
     * Calculates the percentage of the Moon that is illuminated (Phase).
     */
    getMoonIllumination: function(date) {
        var d = exports.toDays(date),
            s = getSunCoordinates(d),
            m = getMoonCoordinates(d),
            sdist = 149598000, // distance from Earth to Sun in km
            phi = acos(sin(s.dec) * sin(m.dec) + cos(s.dec) * cos(m.dec) * cos(s.ra - m.ra)),
            inc = atan(sdist * sin(phi), m.dist - sdist * cos(phi));

        return {
            fraction: (1 + cos(inc)) / 2,
            angle: atan(cos(s.dec) * sin(s.ra - m.ra), sin(s.dec) * cos(m.dec) - cos(s.dec) * sin(m.dec) * cos(s.ra - m.ra))
        };
    },

    /*
     * Calculates the Moon rise/set times for a given date and latitude/longitude.
     */
    getTimes: function(date, lat, lng) {
        var RAn = [0.0, 0.0, 0.0],
            Dec = [0.0, 0.0, 0.0],
            VHz = [0.0, 0.0, 0.0],
            zone = round(-lng/15),
            lw = radians * -lng,
            jd = exports.toDays(date);

        var mp = new Array(3);
        for (var i = 0; i < 3; i++) {
            mp[i] = new Array(3);
            for (var j = 0; j < 3; j++) {
                mp[i][j] = 0.0;
            }
        }

        lng = lng/360;
        var tz = zone/24,
            //t0 = lst(lng, jd, tz)
            t0 = getSiderealTime(jd, lw);

        //jd = jd + tz;

        for (var k = 0; k < 3; k++) {
            var coords = getMoonPosition(jd);
            mp[k][0] = coords.ra;
            mp[k][1] = coords.dec;
            mp[k][2] = coords.plx;
            jd += 0.5;
        }

        if (mp[1][0] <= mp[0][0]) {
            mp[1][0] = mp[1][0] + 2 * PI;
        }

        if (mp[2][0] <= mp[1][0]) {
            mp[2][0] = mp[2][0] + 2 * PI;
        }

        RAn[0] = mp[0][0];
        Dec[0] = mp[0][1];

        var result = {
            moonrise: -1,
            moonset: -1
        };

        // check each hour of day
        for (k = 0; k < 24; k++) {
            var ph = (k + 1) / 24;
            RAn[2] = interpolate(mp[0][0], mp[1][0], mp[2][0], ph);
            Dec[2] = interpolate(mp[0][1], mp[1][1], mp[2][1], ph);
            VHz[2] = moonTest(k, t0, lat, mp[1][2], RAn, Dec, VHz, result);

            RAn[0] = RAn[2];
            Dec[0] = Dec[2];
            VHz[0] = VHz[2];
        }

        if (result.moonrise !== -1) {
            result.moonrise = (Math.floor(date/(1000*60*60*24)) + result.moonrise / 24) * 1000*60*60*24;
        }
        /*
        var rise = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        rise.setTime(rise.getTime() + (result.moonrise*60*60*1000));
        result.moonrise = rise;
        */
        if (result.moonset !== -1) {
            result.moonset = (Math.floor(date/(1000*60*60*24)) + result.moonset / 24) * 1000*60*60*24;
        }
        /*
        var set = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        set.setTime(set.getTime() + (result.moonset*60*60*1000));
        result.moonset = set;
        */

        return result;
    }
};