/*******************************************************************************
 * AquaBeagle
 * Name: lightController.js
 * Copyright (c) 2014. Brian Harris
 * Controller for aquarium lights part of the AquaBeagle aquarium
 * controller.
 ******************************************************************************/

var ephemeris = require('ephemeris');
var pwm = require('pwm');
var config = require('aquaConfig')();

// Declare internals
var internals = {};

internals.now = {
    intervalId: 0
};

internals.update = {
    lastDay: 0,
    dayStatus: "Manual",
    dayError: 0
};

internals.pwm = [0, 0, 0, 0, 0, 0, 0, 0];

internals.cloud = {
    max: [0, 0, 0, 0, 0, 0, 0, 0],
    depth: [0, 0, 0, 0, 0, 0, 0, 0],
    start: [0, 0, 0, 0, 0, 0, 0, 0],
    len: [0, 0, 0, 0, 0, 0, 0, 0],
    ramp: [0, 0, 0, 0, 0, 0, 0, 0],
    adjustment: [0, 0, 0, 0, 0, 0, 0, 0]
};

exports.start = function(options, callback) {
    if (arguments[0] === undefined) {
        arguments[0] = function() { };
    }

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {
            updateInterval: 1000 // Each second
        };
    }

    if (typeof options.updateInterval != "number") {
        options.updateInterval = 1000;
    }

    if (internals.now.intervalId) {
        process.nextTick(function() {
            callback();
        });

        return;
    }

    // Initialize the pwm driver
    // pwm.start() // TODO: if we need to initialize anything on the pwm side
    pwm.setFreq(500); // This is the PWM frequency in Hz, (recommended between 500Hz - 1KHz for most PWM drivers).
    // Initialize pin P9_42 for fan control if configured.
    if (config.fanControl) {
        pwm.setFreq(25000, 7); // 25KHz frequency, standard for DC fans.
        // Disable any light settings on same pin.
        config.pwmSettings[0][7] = 0;
        config.pwmSettings[1][7] = 0;
        config.pwmSettings[2][7] = 0;
    }

    exports.updateLights(options, function (err, status) {
        if (err) {
            return callback(err, status);
        }

        internals.now.intervalId = setInterval(function() {
            exports.updateLights(options, function(err, status) {
                if (err) {
                    console.error(err);
                }

                return callback(err, status);
            });
        }, options.updateInterval);

        return callback(err, status);
    });
};

exports.stop = function() {
    if (!internals.now.intervalId) {
        return;
    }

    clearInterval(internals.now.intervalId);
    internals.now.intervalId = 0;
};

exports.updateLights = function(options, callback) {
    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    // Allow for injecting a date offset to use, used for testing.
    var now = new Date();
    if (options.offset) {
        now.setTime(new Date(now.setMinutes(0)).getTime() + options.offset*60*60*1000); // Offset the time the specified number of hours.
    }

    if (options.intensity) {
        // TODO: Manual controlling of the lights.
        callback();
    }

    if (now.getDay() > internals.update.lastDay || (now.getDay() === 0 && internals.update.lastDay === 6)) {  // Update the time/get ephemeris times once a day.
        internals.update.lastDay = now.getDay();
        // TODO: Set system clock via NTP.
        if (config.controllerMode === "auto") { // Get the ephemeris times, only if in auto mode.
            internals.update.sunTimes = ephemeris.Sun.getTimes(new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate())), config.latitude, config.longitude);
            internals.update.moonTimes = ephemeris.Moon.getTimes(new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate())), config.latitude, config.longitude);
        }
    }

    switch  (config.controllerMode) {
        case "auto":
            if (now > internals.update.sunTimes.night || now <= internals.update.sunTimes.nightEnd) {
                internals.update.dayStatus = "Night";
            } else if (now > internals.update.sunTimes.sunsetStart && now <= internals.update.sunTimes.night) {
                internals.update.dayStatus = "Sunset";
            } else if (now > internals.update.sunTimes.sunriseEnd && now <= internals.update.sunTimes.sunsetStart) {
                internals.update.dayStatus = "Day";
            } else if (now > internals.update.sunTimes.nightEnd && now <= internals.update.sunTimes.sunriseEnd) {
                internals.update.dayStatus = "Sunrise";
            } else {
                internals.update.dayStatus = "Error";
                internals.update.dayError = {
                    sunrise: internals.update.sunTimes.nightEnd,
                    sunset: internals.update.sunTimes.night,
                    sunriseEnd: internals.update.sunTimes.sunriseEnd,
                    sunsetStart: internals.update.sunTimes.sunsetStart
                };
            }
            break;

        default:
            var refDate = new Date(now.getFullYear(), now.getMonth(), now.getDate()),
                sunrise = new Date(),
                sunset = new Date();
                sunrise.setTime(refDate.getTime() + (config.sunriseTime * 1000));
                sunset.setTime(refDate.getTime() + (config.sunsetTime * 1000));
                var sunriseEnd = new Date().setTime(sunrise.getTime() + (config.rampTime * 60 * 1000)),
                sunsetStart = new Date().setTime(sunset.getTime() - (config.rampTime * 60 * 1000));
            if (now > sunset || now <= sunrise) {
                internals.update.dayStatus = "Night";
            } else if (now > sunsetStart && now <= sunset) {
                internals.update.dayStatus = "Sunset";
            } else if (now > sunriseEnd && now <= sunsetStart) {
                internals.update.dayStatus = "Day";
            } else if (now > sunrise && now <= sunriseEnd) {
                internals.update.dayStatus = "Sunrise";
            } else {
                internals.update.dayStatus = "Error";
                internals.update.dayError = {
                    sunset: sunset,
                    sunrise: sunrise,
                    sunriseEnd: sunriseEnd,
                    sunsetStart: sunsetStart
                };
            }
            break;
    }

    if (internals.update.dayStatus === "Night") {
        doLight(1, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: now
            });
        });
    } else if (internals.update.dayStatus === "Sunrise") {
        doRamp(0, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: now
            });
        });
    } else if (internals.update.dayStatus === "Day") {
        doLight(0, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: now
            });
        });
    } else if (internals.update.dayStatus === "Sunset") {
        doRamp(1, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: now
            });
        });
    } else {
        callback(new Error("Could not determine day status."), internals.update.dayError);
    }
};

exports.status = function() {
    return internals.update.dayStatus;
};

exports.currentSettings = function() {
    return internals.pwm;
};

/*
 * Resets the last day that the Ephemeris calculations were ran, so that the
 * next call to updateLights will perform the calculations.
 */
exports.resetEphemeris = function() {
    internals.update.lastDay = 0;
};

function doLight(isNight, now, callback) {
    var phase = 1; // Use whatever is setup in the config.
    if (isNight === 1) {
        if (config.controllerMode === 'auto' && config.simulateMoon &&
            now > internals.update.moonTimes.moonrise &&
            now < internals.update.moonTimes.moonset) { // Simulate the Moon
            // Get the current phase
            phase = ephemeris.Moon.getMoonIllumination(now).fraction;
        } else if (config.controllerMode === 'auto' && config.simulateMoon) { // The Moon is set.
            phase = 0;
        }
    }

    try
    {
        var numChannels = config.pwmSettings[0].length;
        if (config.fanControl) { // Drop last channel if the fan is enabled.
            numChannels--;
        }

        for (var i = 0; i < numChannels; i++) {
            if (isNight === 0) { // Day
                // Turn the fan on max if enabled
                if (config.fanControl) {
                    pwm.setPWM(config.pwmSettings[4][numChannels+1], config.fanMax);
                }
                // Get the setting
                internals.pwm[i] = config.pwmSettings[0][i] - makeCloud(i, now);
                pwm.setPWM(config.pwmSettings[4][i], internals.pwm[i]);
            } else if (isNight === 1) { // Night
                // Turn the fan off if enabled
                if (config.fanControl) {
                    pwm.setPWM(config.pwmSettings[4][numChannels+1], 0);
                }
                // Get the setting
                internals.pwm[i] = config.pwmSettings[1][i] * phase;
                pwm.setPWM(config.pwmSettings[4][i], internals.pwm[i]);
            } else if (isNight === 2) { // Turn off all PWM
                // Turn the fan off if enabled
                if (config.fanControl) {
                    pwm.setPWM(config.pwmSettings[4][numChannels+1], 0);
                }
                internals.pwm[i] = 0;
                pwm.setPWM(config.pwmSettings[4][i], 0);
            }
        }

        callback(null, internals.pwm);
    } catch (err) {
        callback(err, internals.pwm);
    }
}

function doRamp(isSunset, now, callback) {
    // Get current time in seconds from midnight
    var refDate = new Date(now.getFullYear(), now.getMonth(), now.getDate()),
        current = Math.floor(Math.abs(now - refDate) / 1000);

    var numChannels = config.pwmSettings[0].length;
    if (config.fanControl) { // Drop last channel if fan is enabled
        numChannels--;
    }

    try {
        // Turn the fan on max for safety, while ramping.
        if (config.fanControl) {
            pwm.setPWM(config.pwmSettings[4][numChannels+1], config.fanMax);
        }

        for (var i = 0; i < numChannels; i++) {
            if (isSunset === 0) { // Sunrise
                if (config.controllerMode === 'auto') {
                    var rampTime = Math.floor((internals.update.sunTimes.sunriseEnd - internals.update.sunTimes.nightEnd) / (1000 * 60)),
                        sunriseStart = Math.floor((internals.update.sunTimes.nightEnd - refDate) / 1000);
                    internals.pwm[i] = Math.floor(config.pwmSettings[0][i] * (Math.cos((Math.PI / 2) * ((rampTime - config.pwmSettings[2][i]) * 60 - (current - sunriseStart - config.pwmSettings[2][i] * 60)) / ((rampTime - config.pwmSettings[2][i]) * 60))));
                } else {
                    internals.pwm[i] = Math.floor(config.pwmSettings[0][i] * (Math.cos((Math.PI / 2) * ((config.rampTime - config.pwmSettings[2][i]) * 60 - (current - config.sunriseTime - config.pwmSettings[2][i] * 60)) / ((config.rampTime - config.pwmSettings[2][i]) * 60))));
                }
            } else if (isSunset === 1) { // Sunset
                if (config.controllerMode === 'auto') {
                    rampTime = Math.floor((internals.update.sunTimes.night - internals.update.sunTimes.sunsetStart) / (1000 * 60));
                    var sunsetStart = Math.floor((internals.update.sunTimes.sunsetStart - refDate) / 1000);
                    internals.pwm[i] = config.pwmSettings[0][i] - Math.round(config.pwmSettings[0][i] * (1 - Math.cos((Math.PI / 2) * (current - (sunsetStart)) / ((rampTime - config.pwmSettings[2][i]) * 60))));
                } else {
                    internals.pwm[i] = config.pwmSettings[0][i] - Math.round(config.pwmSettings[0][i] * (1 - Math.cos((Math.PI / 2) * (current - (config.sunsetTime - config.rampTime * 60)) / ((config.rampTime - config.pwmSettings[2][i]) * 60))));
                }
            }

            pwm.setPWM(config.pwmSettings[4][i], internals.pwm[i]);
        }

        callback(null, internals.pwm);
    } catch (err) {
        callback(err, internals.pwm);
    }
}

function makeCloud(i, now) {
    return 0;

    if (config.cloudFrequency === 0 || config.pwmSettings[3][i] === 0) { // Do not adjust if cloud is not configured or pin is not part of a channel.
        return 0;
    }

    // Get current time in seconds from midnight
    var refDate = new Date(now.getFullYear(), now.getMonth(), now.getDate()),
        current = Math.floor(Math.abs(now - refDate) / 1000);

    internals.cloud.max[i] = config.pwmSettings[0][i] * (internals.cloud.depth[config.pwmSettings[3][i] - 1] / 10.0); // maximum brightness cut taken for the cloud (70%).
    if (current > internals.cloud.start[config.pwmSettings[3][i] - 1] + internals.cloud.len[config.pwmSettings[3][i] - 1] + 3) { // we're in a "clear" period and should calculate when the next cloud will come.

    } else if (current >= internals.cloud.start[config.pwmSettings[3][i] - 1] && current - internals.cloud.start[config.pwmSettings[3][i] - 1] < internals.cloud.ramp[config.pwmSettings[3][i] - 1]) { // we are ramping up to a cloudy period.

    } /*else if () { // we are ramping down out of the cloud.

    } else if () { // we are in the middle of a cloud.
        // TODO: Lightning effects.
    } */

    return internals.cloud.adjustment[i];
}