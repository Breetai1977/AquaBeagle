/*******************************************************************************
 * AquaBeagle
 * Name: lightController.js
 * Copyright (c) 2014. Brian Harris
 * Controller for aquarium lights part of the AquaBeagle aquarium
 * controller.
 ******************************************************************************/

var ephemeris = require('ephemeris');
var pwm = require('pwm');
var config = require('aquaConfig')();
var gpio = require('gpio');

// Declare internals
var internals = {};

internals.now = {
    intervalId: 0
};

internals.update = {
    lastDay: -1,
    dayStatus: "Manual",
    dayError: 0
};

internals.pwm = [0, 0, 0, 0, 0, 0, 0, 0];

internals.cloud = {
    max: [0, 0, 0, 0, 0, 0, 0, 0],
    depth: [0, 0, 0, 0, 0, 0, 0, 0],
    start: [0, 0, 0, 0, 0, 0, 0, 0],
    len: [0, 0, 0, 0, 0, 0, 0, 0],
    ramp: [0, 0, 0, 0, 0, 0, 0, 0],
    marker: [0, 0, 0, 0, 0, 0, 0, 0],
    adjustment: [0, 0, 0, 0, 0, 0, 0, 0]
};

exports.init = function() {
    // Setup GPIO pin for input manual override switch
    if (config.manualOverridePin !== "") {
        gpio.setup(config.manualOverridePin);
    }
    // Initialize the pwm driver
    // pwm.start() // TODO: if we need to initialize anything on the pwm side
    pwm.setFreq(500); // This is the PWM frequency in Hz, (recommended between 500Hz - 1KHz for most PWM drivers).
    // Initialize pin P9_42 for fan control if configured.
    if (config.fanControl) {
        pwm.setFreq(25000, 7); // 25KHz frequency, standard for DC fans.
        // Disable any light settings on same pin.
        config.pwmSettings[0][7] = 0;
        config.pwmSettings[1][7] = 0;
        config.pwmSettings[2][7] = 0;
    }
};

exports.start = function(options, callback) {
    if (arguments[0] === undefined) {
        arguments[0] = function() { };
    }

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {
            updateInterval: 500 // Half second
        };
    }

    if (typeof options.updateInterval != "number") {
        options.updateInterval = 500;
    }

    if (internals.now.intervalId) {
        process.nextTick(function() {
            callback();
        });

        return;
    }

    checkManualOverride(options, function (err, status) {
        if (err) {
            return callback(err, status);
        }

        internals.now.intervalId = setInterval(function() {
            checkManualOverride(options, function(err, status) {
                if (err) {
                    console.error(err);
                }

                return callback(err, status);
            });
        }, options.updateInterval);

        return callback(err, status);
    });
};

exports.stop = function() {
    if (!internals.now.intervalId) {
        return;
    }

    clearInterval(internals.now.intervalId);
    internals.now.intervalId = 0;
};

exports.updateRealtime = function(options, callback) {
    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    // Manual/Realtime controlling of the lights.
    if (isArray(options.intensity) && isArray(options.pins)) { // Only if the passed in variables are arrays
        try {
            for (var i=0; i<options.pins.length; i++) { // loop the pin array
                pwm.setPWM(options.pins[i], options.intensity[i]); // Set the intensity of the pin
            }

            callback(null, {
                status: "Realtime",
                intensity: options.intensity,
                time: new Date().toString()
            });
        } catch (err) {
            callback(err, {
                status: "Error",
                intensity: options.intensity,
                time: new Date().toString()
            });
        }
    }
};

exports.updateLights = function(options, callback) {
    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    // Allow for injecting a date offset to use, used for testing.
    var now = new Date();
    if (options.offset) {
        now = options.offset;
    }

    // Get the ephermis times for the Sun and Moon if in auto mode and we switched days.
    if ((now.getDay() > internals.update.lastDay || (now.getDay() === 0 && internals.update.lastDay === 6)) && config.controllerMode === "auto") {
        internals.update.lastDay = now.getDay();
        console.log('Getting ephemeris times for the day. ' + now.toString());
        internals.update.sunTimes = ephemeris.Sun.getTimes(now.getFullYear(), now.getMonth()+1, now.getDate(), config.latitude, config.longitude);
        internals.update.moonTimes = ephemeris.Moon.getTimes(now.getFullYear(), now.getMonth()+1, now.getDate(), now.getTimezoneOffset()/60*-1, config.latitude, config.longitude);
    }

    switch  (config.controllerMode) {
        case "auto":
            if (now > ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[1][2]) || now <= ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[1][1])) {
                internals.update.dayStatus = "Night";
            } else if (now > ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[0][2]) && now <= ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[1][2])) {
                internals.update.dayStatus = "Sunset";
            } else if (now > ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[0][1]) && now <= ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[0][2])) {
                internals.update.dayStatus = "Day";
            } else if (now > ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[1][1]) && now <= ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[0][1])) {
                internals.update.dayStatus = "Sunrise";
            } else {
                internals.update.dayStatus = "Error";
                internals.update.dayError = {
                    sunriseStart: ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[1][1]),
                    sunsetEnd: ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[1][2]),
                    sunriseEnd: ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[0][1]),
                    sunsetStart: ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[0][2])
                };
            }
            break;

        default:
            var midnight = Math.floor((now - (new Date().getTimezoneOffset() *1000*60)) / (1000*60*60*24)),
                refDate = midnight * 1000*60*60*24,
                sunrise = refDate + (config.sunriseTime * 1000) + (new Date().getTimezoneOffset() * 1000*60),
                sunset = refDate + (config.sunsetTime * 1000) + (new Date().getTimezoneOffset() * 1000*60),
                sunriseEnd = sunrise + (config.rampTime * 1000*60),
                sunsetStart = sunset - (config.rampTime * 1000*60);
            if (now > sunset || now <= sunrise) {
                internals.update.dayStatus = "Night";
            } else if (now > sunsetStart && now <= sunset) {
                internals.update.dayStatus = "Sunset";
            } else if (now > sunriseEnd && now <= sunsetStart) {
                internals.update.dayStatus = "Day";
            } else if (now > sunrise && now <= sunriseEnd) {
                internals.update.dayStatus = "Sunrise";
            } else {
                internals.update.dayStatus = "Error";
                internals.update.dayError = [
                    sunset,
                    sunrise,
                    sunriseEnd,
                    sunsetStart
                ];
            }
            break;
    }

    if (internals.update.dayStatus === "Night") {
        doLight(1, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: new Date(now).toString()
            });
        });
    } else if (internals.update.dayStatus === "Sunrise") {
        doRamp(0, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: new Date(now).toString()
            });
        });
    } else if (internals.update.dayStatus === "Day") {
        doLight(0, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: new Date(now).toString()
            });
        });
    } else if (internals.update.dayStatus === "Sunset") {
        doRamp(1, now, function(err, intensity) {
            return callback(err, {
                status: internals.update.dayStatus,
                intensity: intensity,
                time: new Date(now).toString()
            });
        });
    } else {
        callback(new Error("Could not determine day status."), {
            status: "Error",
            intensity: internals.update.dayError,
            time: new Date(now).toString()
        });
    }
};

exports.status = function() {
    return internals.update.dayStatus;
};

exports.currentSettings = function() {
    return internals.pwm;
};

/*
 * Resets the last day that the Ephemeris calculations were ran, so that the
 * next call to updateLights will perform the calculations.
 */
exports.resetEphemeris = function() {
    internals.update.lastDay = -1;
};

function checkManualOverride(options, callback) {
    if (config.manualOverridePin !== "") { // If the manual override pin is configured.
        if (gpio.getState(config.manualOverridePin)) {  // Poll the GPIO pin to see if it is high
            // Set the options to update the lights to their configured override intensity.
            options.pins = config.pwmSettings[5];
            options.intensity = config.pwmSettings[4];

            exports.updateRealtime(options, callback);
        } else {
            exports.updateLights(options, callback);
        }
    } else {
        exports.updateLights(options, callback);
}   }

function doLight(isNight, now, callback) {
    var phase = 1; // Initially use whatever is setup in the config.
    if (isNight === 1) {
        if (config.controllerMode === "auto" && config.simulateMoon === 1) {
            var isUp = false,
                rise, set;
            if (internals.update.moonTimes[0] > 0 && internals.update.moonTimes[1] > 0) {
                rise = ephemeris.fromLocalHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.moonTimes[0]);
                set = ephemeris.fromLocalHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.moonTimes[1]);
                if (rise < set) {
                    if (now > rise && now < set) {
                        isUp = true;
                    }
                } else {
                    if (now < set || now > rise) {
                        isUp = true;
                    }
                }
            } else if (internals.update.moonTimes[0] === -2 && internals.update.moonTimes[1] > 0) {
                set = ephemeris.fromLocalHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.moonTimes[1]);
                if (now < set) {
                    isUp = true;
                }
            } else if (internals.update.moonTimes[0] > 0 && internals.update.moonTimes[1] === -1) {
                rise = ephemeris.fromLocalHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.moonTimes[0]);
                if (now > rise) {
                    isUp = true;
                }
            } else if (internals.update.moonTimes[0] === -2 && internals.update.moonTimes[1] === -2) {
                isUp = true;  // I don't expect this block to ever eval to true, but covering my bases for the possible return values from the ephemeris library.
            }

            if (isUp) {
                // Get the current phase
                var fracHours = now.getHours() + (now.getMinutes()/60) + (now.getSeconds()/(60*60));
                phase = ephemeris.Moon.getFraction(now.getFullYear(), now.getMonth()+1, now.getDate(), fracHours);
            } else {
                // Moon is set
                phase = 0;
            }
        }
    }

    try
    {
        var numChannels = config.pwmSettings[0].length;
        if (config.fanControl) { // Drop last channel if the fan is enabled.
            numChannels--;
        }

        for (var i = 0; i < numChannels; i++) {
            if (isNight === 0) { // Day
                // Turn the fan on max if enabled
                if (config.fanControl) {
                    pwm.setPWM(config.pwmSettings[5][numChannels+1], config.fanMax);
                }
                // Get the setting
                internals.pwm[i] = config.pwmSettings[0][i] - makeCloud(i, now);
                pwm.setPWM(config.pwmSettings[5][i], internals.pwm[i]);
            } else if (isNight === 1) { // Night
                // Turn the fan off if enabled
                if (config.fanControl) {
                    pwm.setPWM(config.pwmSettings[5][numChannels+1], 0);
                }
                // Get the setting
                internals.pwm[i] = Math.round(config.pwmSettings[1][i] * phase);
                pwm.setPWM(config.pwmSettings[5][i], internals.pwm[i]);
            } else if (isNight === 2) { // Turn off all PWM
                // Turn the fan off if enabled
                if (config.fanControl) {
                    pwm.setPWM(config.pwmSettings[5][numChannels+1], 0);
                }
                internals.pwm[i] = 0;
                pwm.setPWM(config.pwmSettings[5][i], 0);
            }
        }

        callback(null, internals.pwm);
    } catch (err) {
        callback(err, internals.pwm);
    }
}

function doRamp(isSunset, now, callback) {
    var numChannels = config.pwmSettings[0].length;
    if (config.fanControl) { // Drop last channel if fan is enabled
        numChannels--;
    }

    try {
        // Turn the fan on max for safety, while ramping.
        if (config.fanControl) {
            pwm.setPWM(config.pwmSettings[5][numChannels+1], config.fanMax);
        }

        for (var i = 0; i < numChannels; i++) {
            if (isSunset === 0) { // Sunrise
                if (config.controllerMode === 'auto') {
                    var rampTime = (internals.update.sunTimes[0][1] - internals.update.sunTimes[1][1])*1000*60*60;
                    internals.pwm[i] = Math.round(config.pwmSettings[0][i] * Math.sin((Math.PI / 2) * (Math.max((now.getTime() - ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[1][1]).getTime() - (config.pwmSettings[2][i]*1000)), 0) / rampTime)));
                } else {
                    internals.pwm[i] = Math.round(config.pwmSettings[0][i] * Math.sin((Math.PI / 2) * (Math.max((now.getTime() - ephemeris.fromLocalHours(now.getFullYear(), now.getMonth()+1, now.getDate(), config.sunriseTime/(60*60)).getTime() - (config.pwmSettings[2][i]*1000)), 0) / (config.rampTime * 60*1000))));
                }
            } else if (isSunset === 1) { // Sunset
                if (config.controllerMode === 'auto') {
                    rampTime = (internals.update.sunTimes[1][2] - internals.update.sunTimes[0][2])*1000*60*60;
                    internals.pwm[i] = Math.round(config.pwmSettings[0][i] * Math.cos((Math.PI / 2) * (Math.min((now.getTime() - ephemeris.fromUTCHours(now.getFullYear(), now.getMonth()+1, now.getDate(), internals.update.sunTimes[0][2]).getTime() + (config.pwmSettings[2][i]*1000)), rampTime) / rampTime)));
                } else {
                    internals.pwm[i] = Math.round(config.pwmSettings[0][i] * Math.cos((Math.PI / 2) * (Math.min((now.getTime() - ephemeris.fromLocalHours(now.getUTCFullYear(), now.getMonth()+1, now.getDate(), config.sunsetTime/(60*60)).getTime() + (config.pwmSettings[2][i]*1000)), (config.rampTime * 60*1000)) / (config.rampTime * 60*1000))));
                }
            }

            pwm.setPWM(config.pwmSettings[5][i], internals.pwm[i]);
        }

        callback(null, internals.pwm);
    } catch (err) {
        callback(err, internals.pwm);
    }
}

function makeCloud(i, now) {
    if (config.cloudFrequency === 0 || config.pwmSettings[3][i] === 0) { // Do not adjust if cloud is not configured or pin is not part of a channel.
        return 0;
    }

    internals.cloud.max[i] = config.pwmSettings[0][i] * (internals.cloud.depth[config.pwmSettings[3][i]] / 10.0); // maximum brightness cut taken for the cloud (90%).
    if (now > internals.cloud.start[config.pwmSettings[3][i]] + internals.cloud.len[config.pwmSettings[3][i]] + 3000) { // we're in a "clear" period and should calculate when the next cloud will come.
        internals.cloud.start[config.pwmSettings[3][i]] = new Date(now.getTime() + Math.floor((Math.random()*((13-config.cloudFrequency)*300))+1) * 1000); // when the next cloud will start
        internals.cloud.len[config.pwmSettings[3][i]] = Math.floor((Math.random()*9)+7)*1000; // Random cloud length between 7 and 15 seconds
        internals.cloud.ramp[config.pwmSettings[3][i]] = Math.floor((Math.random() * 3) + 1)*1000; // Random cloud ramp time between 1 and 3 seconds.

        if (internals.cloud.start[config.pwmSettings[3][i]] + internals.cloud.len[config.pwmSettings[3][i]] > internals.update.sunTimes[0][2]) { // tidy up all clouds before sunset starts
            internals.cloud.len[config.pwmSettings[3][i]] = internals.update.sunTimes[0][2] - internals.cloud.start[config.pwmSettings[3][i]];
        }

        internals.cloud.marker[config.pwmSettings[3][i]] = 0;  //prepare for generation of cloud-specific constants
    } else if (now >= internals.cloud.start[config.pwmSettings[3][i]] && now - internals.cloud.start[config.pwmSettings[3][i]] < internals.cloud.ramp[config.pwmSettings[3][i]]) { // we are ramping up to a cloudy period.
        if (internals.cloud.marker[config.pwmSettings[3][i]] === 0) { // generate constants for given cloud
            internals.cloud.timer[config.pwmSettings[3][i]] = now.getTime(); // mark the start of the cloud
            internals.cloud.depth[config.pwmSettings[3][i]] = Math.floor((Math.random()*5)+5);  // random 50% to 90% decrease in brightness for cloud
            internals.cloud.marker[config.pwmSettings[3][i]] = 1;
        }

        // ramp algorithm

    } /*else if () { // we are ramping down out of the cloud.

    } else if (now >= internals.cloud.start[config.pwmSettings[3][i]] + internals.cloud.ramp[config.pwmSettings[3][i]] && now < internals.cloud.start[config.pwmSettings[3][i]]) { // we are in the middle of a cloud.
        // TODO: Lightning effects.
    }
        */
    return internals.cloud.adjustment[i];
}

function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}